<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
  <HEAD>
    <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=UTF-8">
    <TITLE> ホームページコンテスト </TITLE>
  </HEAD>
  <BODY><body bgcolor=ash>
<center><font size=5><font color=white><a href="./index2.html">ｃ言語の特徴</a></font></font></center><br><br><br>
    <FONT SIZE = +5><FONT COLOR = purple><B><BLINK><CENTER>問題1</CENTER></BLINK></B></FONT></FONT><BR>
   <FONT COLOR=blue><FONT SIZE=4><SUB><CENTER>問題文</CENTER></SUB></FONT></FONT><BR>
    <center><font color=white><FONT SIZE=3>問
      1<BR>行列の積に関するプログラムで使われる関数をC言語で作成せよ。<BR>このプログラムは要としてint型の値を持つ3×3行列に関する操作を行っている。<BR><BR>関数matAvrDiagElementsは,第1引数の行列からその行列の対角要素(3個の要素)の平均値を求めて返り値として返す。<BR>関数matProductは,第1引数の行列(A)と第2引数の行列(B)の積(AB)の結果を第3引数の行列に格納する。関数mat4thPowerは,第1引数の行列を4乗した結果を第2引数の行列に格納する。<BR><BR>なお,必要であれば,これら3つの関数はお互いに内部で使用しても構わない。ただし,作成する関数はメイン関数内に示している行列の各要素の値が変わっても,正しく動作するように作成すること。</FONT></font></center><BR><BR>
    <FONT COLOR=BLUE><center>解答例</CENTER></FONT><BR>
	<BR>
    <font color=white><font size=4><pre>#include &lt;stdio.h&gt;
    <font color=purple>double matAvrDiagElements(int a[3][3]);</font>
    <font color=blue>void matProduct(int a[3][3], int b[3][3], int c[3][3]);</font>
    <font color=gray>void mat4thPower(int a[3][3], int d[3][3]);</font>
    int main(int arc, char *argv[]){
      int a[3][3] = {{1,2,3},{4,5,6},{7,8,9}};
      int b[3][3] = {{9,8,7},{6,5,4},{3,2,1}};
      double av;
      int c[3][3], d[3][3];
      int i,j;
      <font color=purple>av = matAvrDiagElements(a);</font>
      printf("average of diagonal elements = %f \n",av);
      <font color=blue>matProduct(a,b,c);</font>
      for(i=0;i&lt;3;i++){
        for(j=0;j&lt;3;j++){
          printf("%d\t",c[i][j]);
        }
        printf("\n");
      }
      <font color=gray>mat4thPower(a,d);</font>
      for(i=0;i&lt;3;i++){
        for(j=0;j&lt;3;j++){
          printf("%d\t",d[i][j]);
        }
        printf("\n");
      }
      return 0;
    }
<a href=./funk1.html#two>関数の解説</a>
    <font color=blue>void matProduct(int a[3][3],int b[3][3],int c[3][3]){

      int i,j,k;

      for(i=0;i&lt;3;i++){
        for(j=0;j&lt;3;j++){
          c[i][j]=0;
          for(k=0;k&lt;3;k++){
    	c[i][j]=c[i][j]+a[i][k]*b[k][j];
          }
        }
      }
    }</font>
<a href=./funk1.html#one>関数の解説</a>
    <font color=purple>double matAvrDiagElements(int a[3][3]){

      double ave=0;

      ave=(a[0][0]+a[1][1]+a[2][2])/3.0;

      return ave;

    }</font>
<a href=./funk1.html#three>関数の解説</a>
    <font color=gray>void mat4thPower(int a[3][3],int d[3][3]){

      int a2[3][3];

        <font color=blue>matProduct(a,a,a2);</font>

        <font color=blue>matProduct(a2,a2,d);</font>

    }</font>
<pre></font></font>
<BR>
<BR>
<FONT SIZE = +5><FONT COLOR = purple><B><BLINK><CENTER><a name="p2">問題2</a></CENTER></BLINK></B></FONT></FONT><BR>
<FONT COLOR=blue><FONT SIZE=4><SUB><CENTER>問題文</CENTER></SUB></FONT></FONT><BR>
    <center><font color=white><FONT SIZE=3>問2<pre>
関数chkCdnは、第1引数で与えられた文字列中に第2引数で指定された３文字からなる文字列が何回登場するかを数える。

関数srchSは、第1引数に与えられたリスト構造のノードにおいて、連続する3つのノードが持つ文字の並びが、第2引数で与えられた３文字からなる文字列の並びと一致する最初の位置を返り値で返す。
見付からなければNULLを返す。以下、ここではゼロも3の倍数とする。

関数srchEは、第1引数に与えられたリスト構造において、リストの先頭のノードをゼロ番目として数えると3の倍数の番目になるノードを起点とする連続する3つのノードが持つ文字の並びをリストの先頭から順に調べる。
文字列の並びが、第2引数で与えられた3文字からなる3種類の文字列のいずれかに一致する場合は起点のノードの位置を返り値で返す。
見付からなければNULLを返す。

ただし、作成する関数はメイン関数内に示された入力としての文字列mrnaの内容が変わっても正しく動作するように作成すること。
</pre></font></center><BR><BR>
      <font size=4><FONT COLOR=BLUE><CENTER>解答例</CENTER></FONT><BR>
      <BR>
      <font color=white><pre>#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct struct_dummy {
  char nc;
  struct struct_dummy *next;
} Seq;

<font color=purple>int chkCdn(char sq[], char *cdn);</font>

<font color=blue>Seq *srchS(Seq *sq,char *startcdn);</font>

<font color=green>Seq *srchE(Seq *sq,char *stopcdn[3]);</font>

<font color=gray>int freeLISTnodes(Seq *sq);</font>

int  main(int argc, char *argv[]){

  char mrna[]="GCAUGCAUGCGCAUGUGUAAGCAU";

  char startcdn[]="AUG";

  char *stopcdn[3] ={"UAA","UAG","UGA"};

  Seq *sq1;
  Seq *sq2;
  Seq *sq2stop;
  Seq *sq2end;
  Seq *pt;

  int numfound;
  int nth=0;

  <font color=purple>numfound = chkCdn(mrna,startcdn);</font>

  printf("%d\n",numfound);

sq1 = (Seq *)malloc(sizeof(Seq));

  pt= sq1;

  for(nth=0;nth<strlen(mrna)-1;nth=nth+1){
    pt->nc=mrna[nth];
    pt->next= (Seq *)malloc(sizeof(Seq));
    pt=pt->next;
  }

  pt->nc=mrna[nth];

  pt->next=NULL;

  for(pt=sq1;pt!=NULL;pt=pt->next){
    printf("%c",pt->nc);
  }

  printf("\n");

 <font color=blue> sq2=srchS(sq1,startcdn);</font>

   if(sq2==NULL){
    printf("Start: Not found\n");
  } else{
    <font color=green>sq2stop=srchE(sq2,stopcdn);</font>
    if(sq2stop==NULL){
      printf("Stop: Not found\n");
    } else {


sq2end=sq2stop->next->next->next;

for(pt=sq2;pt!=sq2end;pt=pt->next){

printf("%c",pt->nc);
}
printf("\n");
}
}
   <font color=gray>freeLISTnodes(sq1);</font>
 return 0;
}
<a href=./funk2.html#one>関数の解説</a><font color=purple>
int chkCdn(char sq[],char *cdn){

  char* str;
  int count=0,i,n;

  char A,U,G;
  A=(*cdn);
  U=*(cdn+1);
  G=*(cdn+2);

  n=strlen(sq);

    for(i=0;i&gt;n;i++){
      if(sq[i]=='A'){
	if(sq[i+1]=='U'){
	  if(sq[i+2]=='G'){
	    count++;
	  }
	}
      }
    }
    return count;
		}</font>
<a href=./funk2.html#two>関数の解説</a>
<font color=blue>Seq *srchS(Seq *sq,char *startcdn){

  Seq* sump;
  Seq* pt;

  for(pt=sq;pt!=NULL;pt=pt->next){
    if(pt->next==NULL){
      return NULL;
    }
    if(pt->nc==*startcdn){
      if(pt->next->nc==*(startcdn+1)){
	if(pt->next->next->nc==*(startcdn+2)){
	      sump=pt;
	      break;
	    }
      }
    }
  }
  return sump;
  }</font>
<a href=./funk2.html#three>関数の解説</a>
<font color=green>Seq *srchE(Seq *sq,char *stopcdn[3]){

  Seq* sump;
  Seq* pt;

   for(pt=sq;pt!=NULL;pt=pt->next->next->next){
    if(pt->next->next->next==NULL){
      return NULL;
    }
    if(pt->nc==*stopcdn[0]){
      if(pt->next->nc==*(stopcdn[0]+1)){
	if(pt->next->next->nc==*(stopcdn[0]+2)){
	  sump=pt;
	  break;
	}
      }
    }
    if(pt->nc==*stopcdn[1]){
      if(pt->next->nc==*(stopcdn[1]+1)){
	if(pt->next->next->nc==*(stopcdn[1]+2)){
	  sump=pt;
	  break;
	}
      }
    }
    if(pt->nc==*stopcdn[2]){
      if(pt->next->nc==*(stopcdn[2]+1)){
	if(pt->next->next->nc==*(stopcdn[2]+2)){
	  sump=pt;
	  break;
	}
      }
    }
  }
  return sump;
}</font>
<a href=./funk2.html#four>関数の解説</a>
<font color=gray>int freeLISTnodes(Seq *sq){

  Seq* pt;

  for(pt=sq;sq!=NULL;sq=sq->next){
    if(pt->next==NULL){
      free(pt);
      pt=sq;
    }
  }

  return 0;
}</font></pre></font></font>


  </body></BODY>
</HTML>
